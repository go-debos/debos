'\" t
.\" Automatically generated by Pandoc 3.1.11.1
.\"
.TH "debos" "1" "" "" ""
.SH NAME
debos \- Debian OS images builder
.SH SYNOPSIS
.IP
.EX
debos [options] <recipe file in YAML>
debos [\-\-help]
.EE
.PP
Application Options:
.IP
.EX
  \-b, \-\-fakemachine\-backend=   Fakemachine backend to use (default: auto)
      \-\-artifactdir=           Directory for packed archives and ostree repositories (default: current directory)
  \-t, \-\-template\-var=          Template variables (use \-t VARIABLE:VALUE syntax)
      \-\-debug\-shell            Fall into interactive shell on error
  \-s, \-\-shell=                 Redefine interactive shell binary (default: bash) (default: /bin/bash)
      \-\-scratchsize=           Size of disk backed scratch space
  \-c, \-\-cpus=                  Number of CPUs to use for build VM (default: 2)
  \-m, \-\-memory=                Amount of memory for build VM (default: 2048MB)
      \-\-show\-boot              Show boot/console messages from the fake machine
  \-e, \-\-environ\-var=           Environment variables (use \-e VARIABLE:VALUE syntax)
  \-v, \-\-verbose                Verbose output
      \-\-print\-recipe           Print final recipe
      \-\-dry\-run                Compose final recipe to build but without any real work started
      \-\-disable\-fakemachine    Do not use fakemachine.
.EE
.SH DESCRIPTION
debos is a tool to make the creation of various Debian\-based OS images
simpler.
While most other tools focus on specific use\-cases, debos is designed
to be a toolchain making common actions trivial while providing enough
rope to do whatever tweaking which might be required behind the scenes.
.PP
debos expects a YAML file as input.
A general overview of a YAML recipe and of the templating engine used
can be found in the \c
.UR
https://pkg.go.dev/github.com/go-debos/debos/actions#hdr-Recipe_syntax
debos recipe syntax documentation
.UE \c
\&.
.PP
debos runs the actions listed in the recipe file sequentially.
These actions should be self\-contained and independent of each other.
.PP
Some of the actions provided by debos to customise and produce images
are:
.IP \[bu] 2
\f[CR]apt\f[R]: install packages and their dependencies with
\f[CR]apt\f[R]
.IP \[bu] 2
\f[CR]debootstrap\f[R]: construct the target rootfs with
\f[CR]debootstrap\f[R]
.IP \[bu] 2
\f[CR]download\f[R]: download a single file from the internet
.IP \[bu] 2
\f[CR]filesystem\-deploy\f[R]: deploy a root filesystem to an image
previously created
.IP \[bu] 2
\f[CR]image\-partition\f[R]: create an image file, make partitions and
format them
.IP \[bu] 2
\f[CR]ostree\-commit\f[R]: create an OSTree commit from rootfs
.IP \[bu] 2
\f[CR]ostree\-deploy\f[R]: deploy an OSTree branch to the image
.IP \[bu] 2
\f[CR]overlay\f[R]: do a recursive copy of directories or files to the
target filesystem
.IP \[bu] 2
\f[CR]pack\f[R]: create a tarball with the target filesystem
.IP \[bu] 2
\f[CR]pacman\f[R]: install packages and their dependencies with pacman
.IP \[bu] 2
\f[CR]pacstrap\f[R]: construct the target rootfs with pacstrap
.IP \[bu] 2
\f[CR]raw\f[R]: directly write a file to the output image at a given
offset
.IP \[bu] 2
\f[CR]recipe\f[R]: includes the recipe actions at the given path
.IP \[bu] 2
\f[CR]run\f[R]: allows to run a command or script in the filesystem or
in the host
.IP \[bu] 2
\f[CR]unpack\f[R]: unpack files from archive in the filesystem
.PP
A full syntax description of all the debos actions can be found in the
\c
.UR https://godoc.org/github.com/go-debos/debos/actions
debos actions documentation
.UE \c
\&.
.SH GET IN TOUCH!
ðŸ’¬ Join us on Matrix at #debos:matrix.debian.social to chat about usage
or development of debos.
.PP
ðŸª² To report a bug, issue or feature request, create a new \c
.UR https://github.com/go-debos/debos/issues
GitHub Issue
.UE \c
\&.
.PP
â“ Please use the \c
.UR https://github.com/go-debos/debos/discussions
GitHub Discussion forum
.UE \c
\ to ask questions about how to use Debos or to discuss best ways of
creating recipes.
.SH INSTALLATION (DOCKER CONTAINER)
An official debos container is available:
.IP
.EX
docker pull godebos/debos
.EE
.PP
See docker/README.md for usage.
.SH USING DEBOS IN GITHUB ACTIONS
debos can be run in GitHub Actions using the official container with KVM
support for isolated and reproducible builds.
The \f[CR]\-\-fakemachine\-backend=kvm\f[R] option is specified to
ensure KVM is used as expected:
.IP
.EX
jobs:
  build:
    runs\-on: ubuntu\-latest
    container:
      image: ghcr.io/go\-debos/debos:main
      options: \-\-device=/dev/kvm
    steps: 
      \- uses: actions/checkout\[at]v4
      \- run: debos \-\-fakemachine\-backend=kvm \-\-print\-recipe recipe.yaml
.EE
.SH INSTALLATION FROM SOURCE (UNDER DEBIAN)
.IP
.EX
sudo apt install golang git libglib2.0\-dev libostree\-dev qemu\-system\-x86 \[rs]
     qemu\-user\-static debootstrap systemd\-container

export GOPATH=/opt/src/gocode # or whatever suits your needs

go install \-v github.com/go\-debos/debos/cmd/debos\[at]latest

/opt/src/gocode/bin/debos \-\-help
.EE
.SH SIMPLE EXAMPLE
The following example will create an arm64 image, install several
packages in it, change the file \f[CR]/etc/hostname\f[R] to
\f[CR]debian\f[R] and finally make a tarball of the complete system.
.IP
.EX
{{\- $image := or .image \[dq]debian.tgz\[dq] \-}}

architecture: arm64

actions:
  \- action: debootstrap
    suite: trixie
    components:
      \- main
      \- non\-free\-firmware
    mirror: https://deb.debian.org/debian
    variant: minbase

  \- action: apt
    packages:
      \- sudo
      \- openssh\-server
      \- adduser
      \- systemd\-sysv
      \- firmware\-linux

  \- action: run
    chroot: true
    command: echo debian > /etc/hostname

  \- action: pack
    file: {{ $image }}
    compression: gz
.EE
.PP
To run it, create a file named \f[CR]example.yaml\f[R] and run:
.IP
.EX
debos example.yaml
.EE
.PP
The final tarball will be named \f[CR]debian.tgz\f[R].
If you would like to modify the fileame, you can provide a different
name for the variable image like this:
.IP
.EX
debos \-t image:\[dq]debian\-arm64.tgz\[dq] example.yaml
.EE
.SH OTHER EXAMPLE RECIPES
See the bundled example recipes for some more detailed example recipes.
Additional more detailed example recipes are stored under \c
.UR https://github.com/go-debos/debos-recipes
debos\-recipes
.UE \c
\&.
.SH ENVIRONMENT VARIABLES
debos reads a predefined list of environment variables from the host and
propagates them to the fakemachine build environment.
The set of environment variables is defined by \f[CR]environ_vars\f[R]
in \f[CR]cmd/debos/debos.go\f[R].
Currently the list of environment variables includes the proxy
environment variables documented at:
.PP
https://wiki.archlinux.org/index.php/proxy_settings
.PP
The list of environment variables currently exported to fakemachine is:
.IP
.EX
http_proxy, https_proxy, ftp_proxy, rsync_proxy, all_proxy, no_proxy
.EE
.PP
While the elements of \f[CR]environ_vars\f[R] are in lower case, for
each element both lower and upper case variants are probed on the host
and if found propagated to fakemachine.
So if the host has the environment variables HTTP_PROXY and no_proxy
defined, both will be propagated to fakemachine respecting the case.
.PP
The command line options \f[CR]\-\-environ\-var\f[R] and \f[CR]\-e\f[R]
can be used to specify, overwrite and unset environment variables for
fakemachine with the syntax:
.IP
.EX
debos \-e ENVIRONVAR:VALUE ...
.EE
.PP
To unset an environment variable, or in other words, to prevent an
environment variable being propagated to fakemachine, use the same
syntax without a value.
debos accepts multiple \-e simultaneously.
.SH PROXY CONFIGURATION
While the proxy related environment variables are exported from the host
to fakemachine, there are two known sources of issues:
.IP \[bu] 2
Using localhost will not work from fakemachine.
Use an address which is valid on your network.
debos will warn if the environment variables contain localhost.
.IP \[bu] 2
In case you are running applications and/or scripts inside fakemachine
you may need to check which are the proxy environment variables they
use.
Different apps are known to use different environment variable names and
different case for environment variable names.
.SH FAKEMACHINE BACKEND
debos (unless running debos with the \f[CR]\-\-disable\-fakemachine\f[R]
argument) creates and spawns a virtual machine using \c
.UR https://github.com/go-debos/fakemachine
fakemachine
.UE \c
\ and executes the actions defined by the recipe inside the virtual
machine.
This helps ensure recipes are reproducible no matter the host
environment.
.PP
Fakemachine can use different virtualisation backends to spawn the
virtual machine, for more information see the \c
.UR https://github.com/go-debos/fakemachine
fakemachine documentation
.UE \c
\&.
.PP
By default the backend will automatically be selected based on what is
supported by the host machine, but this can be overridden using the
\f[CR]\-\-fakemachine\-backend\f[R] / \f[CR]\-b\f[R] option.
If no backends are supported, debos reverts to running the recipe on the
host without creating a fakemachine.
.PP
Performance of the backends is roughly as follows: \f[CR]kvm\f[R] is
faster than \f[CR]uml\f[R] is faster than \f[CR]qemu\f[R].
Using \f[CR]\-\-disable\-fakemachine\f[R] is slightly faster than
\f[CR]kvm\f[R], but requires root permissions.
.PP
Benchmark times for running \c
.UR
https://github.com/go-debos/debos-recipes/blob/9a25b4be6c9136f4a27e542f39ab7e419fc852c9/pine-a64-plus/debian.yaml
pine\-a64\-plus/debian.yaml
.UE \c
\ on an Intel Pentium G4560T with SSD:
.PP
.TS
tab(@);
l l l.
T{
Backend
T}@T{
Wall Time
T}@T{
Prerequisites
T}
_
T{
\f[CR]\-\-disable\-fakemachine\f[R]
T}@T{
8 min
T}@T{
root permissions
T}
T{
\f[CR]\-b kvm\f[R]
T}@T{
9 min
T}@T{
access to \f[CR]/dev/kvm\f[R]
T}
T{
\f[CR]\-b uml\f[R]
T}@T{
18 min
T}@T{
package \f[CR]user\-mode\-linux\f[R] installed
T}
T{
\f[CR]\-b qemu\f[R]
T}@T{
166 min
T}@T{
none
T}
.TE
